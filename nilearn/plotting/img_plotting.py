"""Functions to do automatic visualization of Niimg-like objects.

See http://nilearn.github.io/stable/manipulating_images/input_output.html

Only matplotlib is required.
"""

# Author: Gael Varoquaux, Chris Filo Gorgolewski

import collections.abc
import functools
import numbers
import warnings
from pathlib import Path

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import gridspec as mgs
from matplotlib.colors import LinearSegmentedColormap
from nibabel.spatialimages import SpatialImage
from scipy import stats
from scipy.ndimage import binary_fill_holes

from nilearn.image.resampling import reorder_img
from nilearn.maskers import NiftiMasker
from nilearn.plotting.displays import get_projector, get_slicer
from nilearn.plotting.displays._slicers import _get_cbar_ticks

from .. import _utils
from .._utils import (
    _constrained_layout_kwargs,
    compare_version,
    fill_doc,
    logger,
)
from .._utils.extmath import fast_abs_percentile
from .._utils.ndimage import get_border_data
from .._utils.niimg import safe_get_data
from .._utils.numpy_conversions import as_ndarray
from .._utils.param_validation import check_threshold
from ..datasets import load_mni152_template
from ..image import get_data, iter_img, math_img, new_img_like, resample_to_img
from ..masking import apply_mask, compute_epi_mask
from ..signal import clean
from . import cm


def show():
    """Show all the figures generated by nilearn and/or matplotlib.

    This function is equivalent to :func:`matplotlib.pyplot.show`,
    but is skipped on the 'Agg' backend where it has no effect other
    than to emit a warning.

    """
    if mpl.get_backend().lower() != "agg":  # avoid warnings
        plt.show()


###############################################################################
# Core, usage-agnostic functions


def get_colorbar_and_data_ranges(
    stat_map_data,
    vmin=None,
    vmax=None,
    symmetric_cbar=True,
    force_min_stat_map_value=None,
):
    """Set colormap and colorbar limits.

    Used by plot_stat_map, plot_glass_brain and plot_img_on_surf.

    The limits for the colorbar depend on the symmetric_cbar argument. Please
    refer to docstring of plot_stat_map.
    """
    # handle invalid vmin/vmax inputs
    if (not isinstance(vmin, numbers.Number)) or (not np.isfinite(vmin)):
        vmin = None
    if (not isinstance(vmax, numbers.Number)) or (not np.isfinite(vmax)):
        vmax = None

    # avoid dealing with masked_array:
    if hasattr(stat_map_data, "_mask"):
        stat_map_data = np.asarray(
            stat_map_data[np.logical_not(stat_map_data._mask)]
        )

    if force_min_stat_map_value is None:
        stat_map_min = np.nanmin(stat_map_data)
    else:
        stat_map_min = force_min_stat_map_value
    stat_map_max = np.nanmax(stat_map_data)

    if symmetric_cbar == "auto":
        if (vmin is None) or (vmax is None):
            symmetric_cbar = stat_map_min < 0 < stat_map_max
        else:
            symmetric_cbar = np.isclose(vmin, -vmax)

    # check compatibility between vmin, vmax and symmetric_cbar
    if symmetric_cbar:
        if vmin is None and vmax is None:
            vmax = max(-stat_map_min, stat_map_max)
            vmin = -vmax
        elif vmin is None:
            vmin = -vmax
        elif vmax is None:
            vmax = -vmin
        elif not np.isclose(vmin, -vmax):
            raise ValueError(
                "vmin must be equal to -vmax unless symmetric_cbar is False."
            )
        cbar_vmin = vmin
        cbar_vmax = vmax

    # set colorbar limits
    else:
        negative_range = stat_map_max <= 0
        positive_range = stat_map_min >= 0
        if positive_range:
            cbar_vmin = 0 if vmin is None else vmin
            cbar_vmax = vmax
        elif negative_range:
            cbar_vmax = 0 if vmax is None else vmax
            cbar_vmin = vmin
        else:
            # limit colorbar to plotted values
            cbar_vmin = vmin
            cbar_vmax = vmax

    # set vmin/vmax based on data if they are not already set
    if vmin is None:
        vmin = stat_map_min
    if vmax is None:
        vmax = stat_map_max

    return cbar_vmin, cbar_vmax, vmin, vmax


@fill_doc
def _plot_img_with_bg(
    img,
    bg_img=None,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    colorbar=False,
    figure=None,
    axes=None,
    title=None,
    threshold=None,
    annotate=True,
    draw_cross=True,
    black_bg=False,
    vmin=None,
    vmax=None,
    bg_vmin=None,
    bg_vmax=None,
    interpolation="nearest",
    display_factory=get_slicer,
    cbar_vmin=None,
    cbar_vmax=None,
    cbar_tick_format="%.2g",
    brain_color=(0.5, 0.5, 0.5),
    decimals=False,
    radiological=False,
    **kwargs,
):
    """Refer to the docstring of plot_img for parameters not listed below.

    Parameters
    ----------
    %(img)s
        Image to plot.

    bg_vmin : :obj:`float`, optional
        vmin for `bg_img`.

    bg_vmax : :obj:`float`, optional
        vmax for `bg_img`.

    interpolation : :obj:`str`, default='nearest'
        Passed to the add_overlay calls.

    display_factory : function, default=get_slicer
        Takes a display_mode argument and return a display class.

    kwargs :  extra keyword arguments, optional
        Extra keyword arguments passed
        to the display.add_overlay method (see below).
        Ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or \
        :class:`~nilearn.plotting.displays.OrthoProjector` or None
        An instance of the OrthoSlicer or OrthoProjector class depending on the
        function defined in ``display_factory``. If ``output_file`` is defined,
        None is returned.
    """
    show_nan_msg = False
    if vmax is not None and np.isnan(vmax):
        vmax = None
        show_nan_msg = True
    if vmin is not None and np.isnan(vmin):
        vmin = None
        show_nan_msg = True
    if show_nan_msg:
        nan_msg = (
            "NaN is not permitted for the vmax and vmin arguments.\n"
            "Tip: Use np.nanmax() instead of np.max()."
        )
        warnings.warn(nan_msg)

    if isinstance(cut_coords, numbers.Number) and display_mode in (
        "ortho",
        "tiled",
    ):
        raise ValueError(
            f"The input given for display_mode='{display_mode}' "
            "needs to be a list of 3d world coordinates in (x, y, z). "
            "You provided single cut, "
            f"cut_coords={cut_coords}"
        )

    if img is not False and img is not None:
        img = _utils.check_niimg_3d(img, dtype="auto")
        data = safe_get_data(img, ensure_finite=True)
        affine = img.affine

        if np.isnan(np.sum(data)):
            data = np.nan_to_num(data)

        # Deal with automatic settings of plot parameters
        if threshold == "auto":
            # Threshold epsilon below a percentile value, to be sure that some
            # voxels pass the threshold
            threshold = fast_abs_percentile(data) - 1e-5

        img = new_img_like(img, as_ndarray(data), affine)

    display = display_factory(display_mode)(
        img,
        threshold=threshold,
        cut_coords=cut_coords,
        figure=figure,
        axes=axes,
        black_bg=black_bg,
        colorbar=colorbar,
        brain_color=brain_color,
        radiological=radiological,
    )
    if bg_img is not None:
        bg_img = _utils.check_niimg_3d(bg_img)
        display.add_overlay(
            bg_img,
            vmin=bg_vmin,
            vmax=bg_vmax,
            cmap=plt.cm.gray,
            interpolation=interpolation,
        )

    if img is not None and img is not False:
        display.add_overlay(
            new_img_like(img, data, affine),
            threshold=threshold,
            interpolation=interpolation,
            colorbar=colorbar,
            vmin=vmin,
            vmax=vmax,
            cbar_vmin=cbar_vmin,
            cbar_vmax=cbar_vmax,
            cbar_tick_format=cbar_tick_format,
            **kwargs,
        )
    if radiological:
        for display_axis in display.axes.values():
            display_axis.ax.invert_xaxis()
    if annotate:
        display.annotate(decimals=decimals)
    if draw_cross:
        display.draw_cross()
    if title is not None and title != "":
        display.title(title)
    if hasattr(display, "_cbar"):
        cbar = display._cbar
        new_tick_locs = _get_cropped_cbar_ticks(
            cbar.vmin, cbar.vmax, threshold, n_ticks=len(cbar.locator.locs)
        )
        cbar.set_ticks(new_tick_locs)
    if output_file is not None:
        display.savefig(output_file)
        display.close()
        display = None
    return display


def _get_cropped_cbar_ticks(cbar_vmin, cbar_vmax, threshold=None, n_ticks=5):
    """Return ticks for cropped colorbars."""
    new_tick_locs = np.linspace(cbar_vmin, cbar_vmax, n_ticks)
    if threshold is not None:
        # Case where cbar is either all positive or all negative
        if 0 <= cbar_vmin <= cbar_vmax or cbar_vmin <= cbar_vmax <= 0:
            idx_closest = np.argmin(
                [abs(abs(new_tick_locs) - threshold) for _ in new_tick_locs]
            )
            new_tick_locs[idx_closest] = threshold
        # Case where we do a symmetric thresholding
        # within an asymmetric cbar
        # and both threshold values are within bounds
        elif cbar_vmin <= -threshold <= threshold <= cbar_vmax:
            new_tick_locs = _get_cbar_ticks(
                cbar_vmin, cbar_vmax, threshold, n_ticks=len(new_tick_locs)
            )
        # Case where one of the threshold values is out of bounds
        else:
            idx_closest = np.argmin(
                [abs(new_tick_locs - threshold) for _ in new_tick_locs]
            )
            new_tick_locs[idx_closest] = (
                -threshold if threshold > cbar_vmax else threshold
            )
    return new_tick_locs


@fill_doc
def plot_img(
    img,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    threshold=None,
    annotate=True,
    draw_cross=True,
    black_bg=False,
    colorbar=False,
    cbar_tick_format="%.2g",
    resampling_interpolation="continuous",
    bg_img=None,
    vmin=None,
    vmax=None,
    radiological=False,
    decimals=False,
    **kwargs,
):
    """Plot cuts of a given image.

    By default Frontal, Axial, and Lateral.

    Parameters
    ----------
    %(img)s

    %(cut_coords)s

    %(output_file)s

    %(display_mode)s

    %(figure)s

    %(axes)s

    %(title)s

    %(threshold)s

    %(annotate)s

    decimals : :obj:`int` or :obj:`bool`, default=False
        Number of decimal places on slice position annotation.
        If False (default),
        the slice position is integer without decimal point.

    %(draw_cross)s

    %(black_bg)s
        Default=False.

    %(colorbar)s
        Default=False.

    cbar_tick_format : :obj:`str`, default="%%.2g" (scientific notation)
        Controls how to format the tick labels of the colorbar.
        Ex: use "%%i" to display as integers.

    %(resampling_interpolation)s
        Default='continuous'.

    %(bg_img)s
        If nothing is specified, no background image is plotted.
        Default=None.

    %(vmin)s

    %(vmax)s

    %(radiological)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or None
        An instance of the OrthoSlicer class. If ``output_file`` is defined,
        None is returned.

    .. note::

        This is a low-level function. For most use cases, other plotting
        functions might be more appropriate and easier to use.

    .. seealso::

        :func:`~nilearn.plotting.plot_anat`
            To simply plot anatomical images
        :func:`~nilearn.plotting.plot_epi`
            To simply plot raw EPI images
        :func:`~nilearn.plotting.plot_roi`
            To simply plot max-prob atlases (3D images)
        :func:`~nilearn.plotting.plot_prob_atlas`
            To simply plot probabilistic atlases (4D images)
        :mod:`nilearn.plotting`
            See API reference for other options
    """
    display = _plot_img_with_bg(
        img,
        cut_coords=cut_coords,
        output_file=output_file,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        threshold=threshold,
        annotate=annotate,
        draw_cross=draw_cross,
        resampling_interpolation=resampling_interpolation,
        black_bg=black_bg,
        colorbar=colorbar,
        cbar_tick_format=cbar_tick_format,
        bg_img=bg_img,
        vmin=vmin,
        vmax=vmax,
        radiological=radiological,
        decimals=decimals,
        **kwargs,
    )

    return display


###############################################################################
# Anatomy image for background


# A constant class to serve as a sentinel for the default MNI template
class _MNI152Template(SpatialImage):
    """Constant pointing to the MNI152 Template provided by nilearn."""

    data = None
    _affine = None
    vmax = None
    _shape = None
    # Having a header is required by the load_niimg function
    header = None

    def __init__(self, data=None, affine=None, header=None):
        # Comply with spatial image requirements while allowing empty init
        pass

    def load(self):
        if self.data is None:
            anat_img = load_mni152_template(resolution=2)
            anat_img = reorder_img(anat_img, copy_header=True)
            data = get_data(anat_img)
            data = data.astype(np.float64)
            anat_mask = binary_fill_holes(data > np.finfo(float).eps)
            data = np.ma.masked_array(data, np.logical_not(anat_mask))
            self._affine = anat_img.affine
            self.data = data
            self.vmax = data.max()
            self._shape = anat_img.shape

    @property
    def _data_cache(self):
        self.load()
        return self.data

    @property
    def _dataobj(self):
        self.load()
        return self.data

    def get_data(self):
        self.load()
        return self.data

    @property
    def affine(self):
        self.load()
        return self._affine

    def get_affine(self):
        self.load()
        return self._affine

    @property
    def shape(self):
        self.load()
        return self._shape

    def get_shape(self):
        self.load()
        return self._shape

    def __str__(self):
        return "<MNI152Template>"

    def __repr__(self):
        return "<MNI152Template>"


# The constant that we use as a default in functions
MNI152TEMPLATE = _MNI152Template()


def load_anat(anat_img=MNI152TEMPLATE, dim="auto", black_bg="auto"):
    """Load anatomy, for optional diming."""
    vmin = None
    vmax = None
    if anat_img is False or anat_img is None:
        if black_bg == "auto":
            # No anatomy given: no need to turn black_bg on
            black_bg = False
        return anat_img, black_bg, vmin, vmax

    if anat_img is MNI152TEMPLATE:
        anat_img.load()
        # We special-case the 'canonical anat', as we don't need
        # to do a few transforms to it.
        vmin = 0
        vmax = anat_img.vmax
        if black_bg == "auto":
            black_bg = False
    else:
        anat_img = _utils.check_niimg_3d(anat_img)
        # Clean anat_img for non-finite values to avoid computing unnecessary
        # border data values.
        data = safe_get_data(anat_img, ensure_finite=True)
        anat_img = new_img_like(anat_img, data, affine=anat_img.affine)
        if dim or black_bg == "auto":
            # We need to inspect the values of the image
            vmin = np.nanmin(data)
            vmax = np.nanmax(data)
        if black_bg == "auto":
            # Guess if the background is rather black or light based on
            # the values of voxels near the border
            background = np.median(get_border_data(data, 2))
            black_bg = not (background > 0.5 * (vmin + vmax))
    if dim:
        if dim != "auto" and not isinstance(dim, numbers.Number):
            raise ValueError(
                "The input given for 'dim' needs to be a float. "
                f"You provided dim={dim} in {type(dim)}."
            )
        vmean = 0.5 * (vmin + vmax)
        ptp = 0.5 * (vmax - vmin)
        if black_bg:
            if not isinstance(dim, numbers.Number):
                dim = 0.8
            vmax = vmean + (1 + dim) * ptp
        else:
            if not isinstance(dim, numbers.Number):
                dim = 0.6
            vmin = 0.5 * (2 - dim) * vmean - (1 + dim) * ptp
    return anat_img, black_bg, vmin, vmax


###############################################################################
# Usage-specific functions


@fill_doc
def plot_anat(
    anat_img=MNI152TEMPLATE,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    annotate=True,
    threshold=None,
    draw_cross=True,
    black_bg="auto",
    dim="auto",
    cmap=plt.cm.gray,
    colorbar=False,
    cbar_tick_format="%.2g",
    radiological=False,
    vmin=None,
    vmax=None,
    **kwargs,
):
    """Plot cuts of an anatomical image.

    By default 3 cuts: Frontal, Axial, and Lateral.

    Parameters
    ----------
    anat_img : Niimg-like object, default=MNI152TEMPLATE
        See :ref:`extracting_data`.
        The anatomical image to be used as a background. If None is
        given, nilearn tries to find a T1 template.

    %(cut_coords)s

    %(output_file)s

    %(display_mode)s

    %(figure)s

    %(axes)s

    %(title)s

    %(annotate)s

    %(threshold)s

    %(draw_cross)s

    %(black_bg)s
        Default='auto'.

    %(dim)s
        Default='auto'.

    %(cmap)s
        Default=`plt.cm.gray`.

    colorbar : :obj:`bool`, default=False
        If True, display a colorbar on the right of the plots.

    cbar_tick_format : :obj:`str`, default="%%.2g" (scientific notation)
        Controls how to format the tick labels of the colorbar.
        Ex: use "%%i" to display as integers.

    %(radiological)s

    %(vmin)s

    %(vmax)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or None
        An instance of the OrthoSlicer class. If ``output_file`` is defined,
        None is returned.

    Notes
    -----
    Arrays should be passed in numpy convention: (x, y, z) ordered.

    For visualization, non-finite values found in passed 'anat_img'
    are set to zero.

    """
    anat_img, black_bg, anat_vmin, anat_vmax = load_anat(
        anat_img, dim=dim, black_bg=black_bg
    )

    if vmin is None:
        vmin = anat_vmin
    if vmax is None:
        vmax = anat_vmax

    display = plot_img(
        anat_img,
        cut_coords=cut_coords,
        output_file=output_file,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        threshold=threshold,
        annotate=annotate,
        draw_cross=draw_cross,
        black_bg=black_bg,
        colorbar=colorbar,
        cbar_tick_format=cbar_tick_format,
        vmin=vmin,
        vmax=vmax,
        cmap=cmap,
        radiological=radiological,
        **kwargs,
    )
    return display


@fill_doc
def plot_epi(
    epi_img=None,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    annotate=True,
    draw_cross=True,
    black_bg=True,
    colorbar=False,
    cbar_tick_format="%.2g",
    cmap=plt.cm.nipy_spectral,
    vmin=None,
    vmax=None,
    radiological=False,
    **kwargs,
):
    """Plot cuts of an :term:`EPI` image.

    By default 3 cuts: Frontal, Axial, and Lateral.

    Parameters
    ----------
    epi_img : a Niimg-like object or None, default=None
        The :term:`EPI` (T2*) image.

    %(cut_coords)s

    %(output_file)s

    %(display_mode)s

    %(figure)s

    %(axes)s

    %(title)s

    %(annotate)s

    %(draw_cross)s

    %(black_bg)s
        Default=True.

    colorbar : :obj:`bool`, default=False
        If True, display a colorbar on the right of the plots.

    cbar_tick_format : :obj:`str`, default="%%.2g" (scientific notation)
        Controls how to format the tick labels of the colorbar.
        Ex: use "%%i" to display as integers.

    %(cmap)s
        Default=`plt.cm.nipy_spectral`.

    %(vmin)s

    %(vmax)s

    %(radiological)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or None
        An instance of the OrthoSlicer class. If ``output_file`` is defined,
        None is returned.

    Notes
    -----
    Arrays should be passed in numpy convention: (x, y, z) ordered.
    """
    display = plot_img(
        epi_img,
        cut_coords=cut_coords,
        output_file=output_file,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        threshold=None,
        annotate=annotate,
        draw_cross=draw_cross,
        black_bg=black_bg,
        colorbar=colorbar,
        cbar_tick_format=cbar_tick_format,
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
        radiological=radiological,
        **kwargs,
    )
    return display


def _plot_roi_contours(display, roi_img, cmap, alpha, linewidths):
    """Help for plotting regions of interest ROIs in contours.

    Parameters
    ----------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer`, object
        An object with background image on which contours are shown.

    roi_img : Niimg-like object
        See :ref:`extracting_data`.
        The ROI/mask image, it could be binary mask or an atlas or ROIs
        with integer values.

    cmap : matplotlib colormap
        The colormap for the atlas maps.

    alpha : :obj:`float` between 0 and 1
        Alpha sets the transparency of the color inside the filled
        contours.

    linewidths : :obj:`float`
        This option can be used to set the boundary thickness of the
        contours.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer`, object
        Contours displayed on the background image.

    """
    roi_img = _utils.check_niimg_3d(roi_img)
    roi_data = get_data(roi_img)
    labels = np.unique(roi_data)
    cmap = plt.get_cmap(cmap)
    color_list = cmap(np.linspace(0, 1, len(labels)))
    for idx, label in enumerate(labels):
        if label == 0:
            continue
        data = roi_data == label
        data = data.astype(np.int32)
        img = new_img_like(roi_img, data, affine=roi_img.affine)
        display.add_contours(
            img,
            levels=[0.5],
            colors=[color_list[idx - 1]],
            alpha=alpha,
            linewidths=linewidths,
            linestyles="solid",
        )
    return display


@fill_doc
def plot_roi(
    roi_img,
    bg_img=MNI152TEMPLATE,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    annotate=True,
    draw_cross=True,
    black_bg="auto",
    threshold=0.5,
    alpha=0.7,
    cmap=plt.cm.gist_ncar,
    dim="auto",
    colorbar=False,
    cbar_tick_format="%i",
    vmin=None,
    vmax=None,
    resampling_interpolation="nearest",
    view_type="continuous",
    linewidths=2.5,
    radiological=False,
    **kwargs,
):
    """Plot cuts of an ROI/mask image.

    By default 3 cuts: Frontal, Axial, and Lateral.

    Parameters
    ----------
    roi_img : Niimg-like object
        See :ref:`extracting_data`.
        The ROI/mask image, it could be binary mask or an atlas or ROIs
        with integer values.

    %(bg_img)s
        If nothing is specified, the MNI152 template will be used.
        To turn off background image, just pass "bg_img=None".
        Default=MNI152TEMPLATE.

    %(cut_coords)s

    %(output_file)s

    %(display_mode)s

    %(figure)s

    %(axes)s

    %(title)s

    %(annotate)s

    %(draw_cross)s

    %(black_bg)s
        Default='auto'.

    %(threshold)s
        Default=0.5.

    alpha : :obj:`float` between 0 and 1, default=0.7
        Alpha sets the transparency of the color inside the filled
        contours.

    %(cmap)s
        Default=`plt.cm.gist_ncar`.

    %(dim)s
        Default='auto'.

    colorbar : :obj:`bool`, default=False
        If True, display a colorbar on the right of the plots.

    cbar_tick_format : :obj:`str`, default="%%i"
        Controls how to format the tick labels of the colorbar.
        Ex: use "%%.2g" to use scientific notation.

    %(vmin)s

    %(vmax)s

    %(resampling_interpolation)s
        Default='nearest'.

    view_type : {'continuous', 'contours'}, default='continuous'
        By default view_type == 'continuous',
        rois are shown as continuous colors.
        If view_type == 'contours', maps are shown as contours.
        For this type, label
        denoted as 0 is considered as background and not shown.

    %(linewidths)s
        Default=2.5.

    %(radiological)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or None
        An instance of the OrthoSlicer class. If ``output_file`` is defined,
        None is returned.

    Notes
    -----
    A small threshold is applied by default to eliminate numerical
    background noise.

    For visualization, non-finite values found in passed 'roi_img' or
    'bg_img' are set to zero.

    See Also
    --------
    nilearn.plotting.plot_prob_atlas : To simply plot probabilistic atlases
        (4D images)
    """
    valid_view_types = ["continuous", "contours"]
    if view_type not in valid_view_types:
        raise ValueError(
            f"Unknown view type: {view_type}. "
            f"Valid view types are {valid_view_types}."
        )
    elif view_type == "contours":
        img = roi_img
        roi_img = None

    bg_img, black_bg, bg_vmin, bg_vmax = load_anat(
        bg_img, dim=dim, black_bg=black_bg
    )

    display = _plot_img_with_bg(
        img=roi_img,
        bg_img=bg_img,
        cut_coords=cut_coords,
        output_file=output_file,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        annotate=annotate,
        draw_cross=draw_cross,
        black_bg=black_bg,
        threshold=threshold,
        bg_vmin=bg_vmin,
        bg_vmax=bg_vmax,
        resampling_interpolation=resampling_interpolation,
        colorbar=colorbar,
        cbar_tick_format=cbar_tick_format,
        alpha=alpha,
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
        radiological=radiological,
        **kwargs,
    )

    if view_type == "contours":
        display = _plot_roi_contours(
            display, img, cmap=cmap, alpha=alpha, linewidths=linewidths
        )

    return display


@fill_doc
def plot_prob_atlas(
    maps_img,
    bg_img=MNI152TEMPLATE,
    view_type="auto",
    threshold="auto",
    linewidths=2.5,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    annotate=True,
    draw_cross=True,
    black_bg="auto",
    dim="auto",
    colorbar=False,
    cmap=plt.cm.gist_rainbow,
    vmin=None,
    vmax=None,
    alpha=0.7,
    radiological=False,
    **kwargs,
):
    """Plot a :term:`Probabilistic atlas` onto the anatomical image \
    by default :term:`MNI` template.

    Parameters
    ----------
    maps_img : Niimg-like object or the filename
        4D image of the :term:`Probabilistic atlas` maps.

    %(bg_img)s
        If nothing is specified, the MNI152 template will be used.
        To turn off background image, just pass "bg_img=False".
        Default=MNI152TEMPLATE.

        .. versionadded:: 0.4.0

    view_type : {'auto', 'contours', 'filled_contours', 'continuous'}, \
                default='auto'
        If view_type == 'auto', it means maps will be displayed
        automatically using any one of the three view types. The automatic
        selection of view type depends on the total number of maps.
        If view_type == 'contours', maps are overlaid as contours
        If view_type == 'filled_contours', maps are overlaid as contours
        along with color fillings inside the contours.
        If view_type == 'continuous', maps are overlaid as continuous
        colors irrespective of the number maps.

    threshold : a :obj:`str` or a number, :obj:`list` of :obj:`str` or \
        numbers, default='auto'
        This parameter is optional and is used to threshold the maps image
        using the given value or automatically selected value. The values
        in the image above the threshold level will be visualized.
        The default strategy, computes a threshold level that seeks to
        minimize (yet not eliminate completely) the overlap between several
        maps for a better visualization.
        The threshold can also be expressed as a percentile over the values
        of the whole atlas. In that case, the value must be specified as
        string finishing with a percent sign, e.g., "25.3%%".
        If a single string is provided, the same percentile will be applied
        over the whole atlas. Otherwise, if a list of percentiles is
        provided, each 3D map is thresholded with certain percentile
        sequentially. Length of percentiles given should match the number
        of 3D map in time (4th) dimension.
        If a number or a list of numbers, the given value will be used
        directly to threshold the maps without any percentile calculation.
        If None, a very small threshold is applied to remove numerical
        noise from the maps background.

    %(linewidths)s
        Default=2.5.

    %(cut_coords)s

    %(output_file)s

    %(display_mode)s

    %(figure)s

    %(axes)s

    %(title)s

    %(annotate)s

    %(draw_cross)s

    %(black_bg)s
        Default='auto'.

    %(dim)s
        Default='auto'.

    %(cmap)s
        Default=`plt.cm.gist_rainbow`.

    %(colorbar)s
        Default=False.

    %(vmin)s

    %(vmax)s

    alpha : :obj:`float` between 0 and 1, default=0.7
        Alpha sets the transparency of the color inside the filled contours.
    %(radiological)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or None
        An instance of the OrthoSlicer class. If ``output_file`` is defined,
        None is returned.

    See Also
    --------
    nilearn.plotting.plot_roi : To simply plot max-prob atlases (3D images)
    """
    display = plot_anat(
        bg_img,
        cut_coords=cut_coords,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        annotate=annotate,
        draw_cross=draw_cross,
        black_bg=black_bg,
        dim=dim,
        radiological=radiological,
        vmin=vmin,
        vmax=vmax,
        **kwargs,
    )

    maps_img = _utils.check_niimg_4d(maps_img)
    n_maps = maps_img.shape[3]

    valid_view_types = ["auto", "contours", "filled_contours", "continuous"]
    if view_type not in valid_view_types:
        raise ValueError(
            f"Unknown view type: {view_type}. "
            f"Valid view types are {valid_view_types}."
        )

    cmap = plt.get_cmap(cmap)
    color_list = cmap(np.linspace(0, 1, n_maps))

    if view_type == "auto":
        if n_maps > 20:
            view_type = "contours"
        elif n_maps > 10:
            view_type = "filled_contours"
        else:
            view_type = "continuous"

    if threshold is None:
        threshold = 1e-6
    elif threshold == "auto":
        # it will use default percentage,
        # strategy is to avoid maximum overlaps as possible
        if view_type == "contours":
            correction_factor = 1
        elif view_type == "filled_contours":
            correction_factor = 0.8
        else:
            correction_factor = 0.5
        threshold = f"{100 * (1 - 0.2 * correction_factor / n_maps):f}%"

    if isinstance(threshold, collections.abc.Iterable) and not isinstance(
        threshold, str
    ):
        threshold = list(threshold)
        if len(threshold) != n_maps:
            raise TypeError(
                "The list of values to threshold "
                "should be equal to number of maps"
            )
    else:
        threshold = [threshold] * n_maps

    filled = view_type.startswith("filled")
    for map_img, color, thr in zip(iter_img(maps_img), color_list, threshold):
        data = get_data(map_img)
        # To threshold or choose the level of the contours
        thr = check_threshold(
            thr, data, percentile_func=fast_abs_percentile, name="threshold"
        )
        # Get rid of background values in all cases
        thr = max(thr, 1e-6)

        if view_type == "continuous":
            display.add_overlay(
                map_img, threshold=thr, cmap=cm.alpha_cmap(color), alpha=alpha
            )
        else:
            display.add_contours(
                map_img,
                levels=[thr],
                linewidths=linewidths,
                colors=[color],
                filled=filled,
                alpha=alpha,
                linestyles="solid",
            )
    if colorbar:
        display._colorbar = True
        # Create a colormap from color list to feed display
        cmap = LinearSegmentedColormap.from_list(
            "segmented colors", color_list, n_maps + 1
        )
        display._show_colorbar(cmap, mpl.colors.Normalize(1, n_maps + 1))
        tick_locator = mpl.ticker.MaxNLocator(nbins=10)
        display.locator = tick_locator
        display._cbar.update_ticks()
        tick_location = np.round(
            np.linspace(1, n_maps, min(n_maps, 10))
        ).astype("int")
        display._cbar.set_ticks(tick_location + 0.5)
        display._cbar.set_ticklabels(tick_location)
        (
            left,
            bottom,
            width,
            height,
        ) = display._colorbar_ax.get_position().bounds
        display._colorbar_ax.set_position([left, bottom, width, height * 0.95])
        display._colorbar_ax.annotate(
            "Map #",
            xy=(1, 1.03),
            ha="right",
            va="bottom",
            xycoords="axes fraction",
        )
    if output_file is not None:
        display.savefig(output_file)
        display.close()
        display = None

    return display


@fill_doc
def plot_stat_map(
    stat_map_img,
    bg_img=MNI152TEMPLATE,
    cut_coords=None,
    output_file=None,
    display_mode="ortho",
    colorbar=True,
    cbar_tick_format="%.2g",
    figure=None,
    axes=None,
    title=None,
    threshold=1e-6,
    annotate=True,
    draw_cross=True,
    black_bg="auto",
    cmap=cm.cold_hot,
    symmetric_cbar="auto",
    dim="auto",
    vmin=None,
    vmax=None,
    radiological=False,
    resampling_interpolation="continuous",
    **kwargs,
):
    """Plot cuts of an ROI/mask image.

    By default 3 cuts: Frontal, Axial, and Lateral.

    Parameters
    ----------
    stat_map_img : Niimg-like object
        See :ref:`extracting_data`.
        The statistical map image

    %(bg_img)s
        If nothing is specified, the MNI152 template will be used.
        To turn off background image, just pass "bg_img=None".
        Default=MNI152TEMPLATE.

    %(cut_coords)s

    %(output_file)s

    %(display_mode)s

    %(colorbar)s
        Default=True.

    cbar_tick_format : :obj:`str`, default="%%.2g" (scientific notation)
        Controls how to format the tick labels of the colorbar.
        Ex: use "%%i" to display as integers.

    %(figure)s

    %(axes)s

    %(title)s

    %(threshold)s
        Default=1e-6.

    %(annotate)s

    %(draw_cross)s

    %(black_bg)s
        Default='auto'.

    %(cmap)s

        .. note::
            The colormap *must* be symmetrical.

        Default=`plt.cm.cold_hot`.

    %(symmetric_cbar)s

    %(dim)s
        Default='auto'.

    %(vmin)s

    %(vmax)s

    %(resampling_interpolation)s
        Default='continuous'.

    %(radiological)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoSlicer` or None
        An instance of the OrthoSlicer class. If ``output_file`` is defined,
        None is returned.

    Notes
    -----
    Arrays should be passed in numpy convention: (x, y, z) ordered.

    For visualization, non-finite values found in passed 'stat_map_img' or
    'bg_img' are set to zero.

    See Also
    --------
    nilearn.plotting.plot_anat : To simply plot anatomical images
    nilearn.plotting.plot_epi : To simply plot raw EPI images
    nilearn.plotting.plot_glass_brain : To plot maps in a glass brain
    """
    # dim the background
    bg_img, black_bg, bg_vmin, bg_vmax = load_anat(
        bg_img, dim=dim, black_bg=black_bg
    )

    stat_map_img = _utils.check_niimg_3d(stat_map_img, dtype="auto")

    cbar_vmin, cbar_vmax, vmin, vmax = get_colorbar_and_data_ranges(
        safe_get_data(stat_map_img, ensure_finite=True),
        vmin=vmin,
        vmax=vmax,
        symmetric_cbar=symmetric_cbar,
    )

    display = _plot_img_with_bg(
        img=stat_map_img,
        bg_img=bg_img,
        cut_coords=cut_coords,
        output_file=output_file,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        annotate=annotate,
        draw_cross=draw_cross,
        black_bg=black_bg,
        threshold=threshold,
        bg_vmin=bg_vmin,
        bg_vmax=bg_vmax,
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
        colorbar=colorbar,
        cbar_tick_format=cbar_tick_format,
        cbar_vmin=cbar_vmin,
        cbar_vmax=cbar_vmax,
        resampling_interpolation=resampling_interpolation,
        radiological=radiological,
        **kwargs,
    )

    return display


@fill_doc
def plot_glass_brain(
    stat_map_img,
    output_file=None,
    display_mode="ortho",
    colorbar=False,
    cbar_tick_format="%.2g",
    figure=None,
    axes=None,
    title=None,
    threshold="auto",
    annotate=True,
    black_bg=False,
    cmap=None,
    alpha=0.7,
    vmin=None,
    vmax=None,
    plot_abs=True,
    symmetric_cbar="auto",
    resampling_interpolation="continuous",
    radiological=False,
    **kwargs,
):
    """Plot 2d projections of an ROI/mask image (by default 3 projections:
    Frontal, Axial, and Lateral). The brain glass schematics
    are added on top of the image.

    The plotted image should be in :term:`MNI` space for this function to work
    properly.

    Only glass brain can be plotted by switching stat_map_img to None.

    Parameters
    ----------
    stat_map_img : Niimg-like object
        See :ref:`extracting_data`.
        The statistical map image.
        It needs to be in :term:`MNI` space
        in order to align with the brain schematics.

    %(output_file)s

    display_mode : :obj:`str`, default='ortho'
        Choose the direction of the cuts: 'x' - sagittal, 'y' - coronal,
        'z' - axial, 'l' - sagittal left hemisphere only,
        'r' - sagittal right hemisphere only, 'ortho' - three cuts are
        performed in orthogonal directions. Possible values are: 'ortho',
        'x', 'y', 'z', 'xz', 'yx', 'yz', 'l', 'r', 'lr', 'lzr', 'lyr',
        'lzry', 'lyrz'.

    %(colorbar)s
        Default=False.

    cbar_tick_format : :obj:`str`, default="%%.2g" (scientific notation)
        Controls how to format the tick labels of the colorbar.
        Ex: use "%%i" to display as integers.

    %(figure)s

    %(axes)s

    %(title)s

    %(threshold)s
        Default='auto'.

    %(annotate)s

    %(black_bg)s
        Default=False.

    %(cmap)s
        Default=None.

    alpha : :obj:`float` between 0 and 1, default=0.7
        Alpha transparency for the brain schematics.

    %(vmin)s

    %(vmax)s

    plot_abs : :obj:`bool`, default=True
        If set to True maximum intensity projection of the
        absolute value will be used (rendering positive and negative
        values in the same manner). If set to false the sign of the
        maximum intensity will be represented with different colors.
        See
        :ref:`sphx_glr_auto_examples_01_plotting_plot_demo_glass_brain_extensive.py`
        for examples.

    %(symmetric_cbar)s

    %(resampling_interpolation)s
        Default='continuous'.

    %(radiological)s

    kwargs : extra keyword arguments, optional
        Extra keyword arguments
        ultimately passed to `matplotlib.pyplot.imshow` via
        :meth:`~nilearn.plotting.displays.BaseSlicer.add_overlay`.

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoProjector` or None
        An instance of the OrthoProjector class. If ``output_file`` is defined,
        None is returned.

    Notes
    -----
    Arrays should be passed in numpy convention: (x, y, z) ordered.
    """
    if cmap is None:
        cmap = cm.cold_hot if black_bg else cm.cold_white_hot
        # use only positive half of colormap if plotting absolute values
        if plot_abs:
            cmap = LinearSegmentedColormap.from_list(
                "cmap_pos",
                cmap(np.linspace(0.5, 1, 256)),
            )

    if stat_map_img:
        stat_map_img = _utils.check_niimg_3d(stat_map_img, dtype="auto")
        if plot_abs:
            if vmin is not None and vmin < 0:
                warnings.warn(
                    "vmin is negative but plot_abs is True",
                    category=UserWarning,
                )
            force_min_stat_map_value = 0
        else:
            force_min_stat_map_value = None

        cbar_vmin, cbar_vmax, vmin, vmax = get_colorbar_and_data_ranges(
            safe_get_data(stat_map_img, ensure_finite=True),
            vmin=vmin,
            vmax=vmax,
            symmetric_cbar=symmetric_cbar,
            force_min_stat_map_value=force_min_stat_map_value,
        )
    else:
        cbar_vmin, cbar_vmax = None, None

    def display_factory(display_mode):
        return functools.partial(
            get_projector(display_mode), alpha=alpha, plot_abs=plot_abs
        )

    display = _plot_img_with_bg(
        img=stat_map_img,
        output_file=output_file,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        annotate=annotate,
        black_bg=black_bg,
        threshold=threshold,
        cmap=cmap,
        colorbar=colorbar,
        cbar_tick_format=cbar_tick_format,
        display_factory=display_factory,
        vmin=vmin,
        vmax=vmax,
        cbar_vmin=cbar_vmin,
        cbar_vmax=cbar_vmax,
        resampling_interpolation=resampling_interpolation,
        radiological=radiological,
        **kwargs,
    )

    if stat_map_img is None and "l" in display.axes:
        display.axes["l"].ax.invert_xaxis()

    return display


@fill_doc
def plot_connectome(
    adjacency_matrix,
    node_coords,
    node_color="auto",
    node_size=50,
    edge_cmap=cm.bwr,
    edge_vmin=None,
    edge_vmax=None,
    edge_threshold=None,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    annotate=True,
    black_bg=False,
    alpha=0.7,
    edge_kwargs=None,
    node_kwargs=None,
    colorbar=False,
    radiological=False,
):
    """Plot connectome on top of the brain glass schematics.

    The plotted image should be in :term:`MNI` space for this function to work
    properly.

    In the case of 'l' and 'r' directions (for hemispheric projections),
    markers in the coordinate x == 0 are included in both hemispheres.

    Parameters
    ----------
    adjacency_matrix : numpy array of shape (n, n)
        Represents the link strengths of the graph. The matrix can be
        symmetric which will result in an undirected graph, or not
        symmetric which will result in a directed graph.

    node_coords : numpy array_like of shape (n, 3)
        3d coordinates of the graph nodes in world space.

    node_color : color or sequence of colors or 'auto', default='auto'
        Color(s) of the nodes. If string is given, all nodes
        are plotted with same color given in string.

    node_size : scalar or array_like, default=50
        Size(s) of the nodes in points^2.

    edge_cmap : colormap, default=cm.bwr
        Colormap used for representing the strength of the edges.

    edge_vmin, edge_vmax : :obj:`float` or None, default=None
        If not None, either or both of these values will be used to
        as the minimum and maximum values to color edges. If None are
        supplied the maximum absolute value within the given threshold
        will be used as minimum (multiplied by -1) and maximum
        coloring levels.

    edge_threshold : :obj:`str`, number or None, default=None
        If it is a number only the edges with a value greater than
        edge_threshold will be shown.
        If it is a string it must finish with a percent sign,
        e.g. "25.3%%", and only the edges with a abs(value) above
        the given percentile will be shown.
    %(output_file)s
    display_mode : :obj:`str`, default='ortho'
        Choose the direction of the cuts: 'x' - sagittal, 'y' - coronal,
        'z' - axial, 'l' - sagittal left hemisphere only,
        'r' - sagittal right hemisphere only, 'ortho' - three cuts are
        performed in orthogonal directions. Possible values are: 'ortho',
        'x', 'y', 'z', 'xz', 'yx', 'yz', 'l', 'r', 'lr', 'lzr', 'lyr',
        'lzry', 'lyrz'.
    %(figure)s
    %(axes)s
    %(title)s
    %(annotate)s
    %(black_bg)s
        Default=False.
    alpha : :obj:`float` between 0 and 1, default=0.7
        Alpha transparency for the brain schematics.

    edge_kwargs : :obj:`dict` or None, default=None
        Will be passed as kwargs for each edge matlotlib Line2D.

    node_kwargs : :obj:`dict` or None, default=None
        Will be passed as kwargs to the plt.scatter call that plots all
        the nodes in one go.
    %(colorbar)s
        Default=False.
    %(radiological)s

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoProjector` or None
        An instance of the OrthoProjector class. If ``output_file`` is defined,
        None is returned.

    See Also
    --------
    nilearn.plotting.find_parcellation_cut_coords : Extraction of node
        coords on brain parcellations.
    nilearn.plotting.find_probabilistic_atlas_cut_coords : Extraction of
        node coords on brain probabilistic atlases.

    """
    display = plot_glass_brain(
        None,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        annotate=annotate,
        black_bg=black_bg,
        alpha=alpha,
        radiological=radiological,
    )

    display.add_graph(
        adjacency_matrix,
        node_coords,
        node_color=node_color,
        node_size=node_size,
        edge_cmap=edge_cmap,
        edge_vmin=edge_vmin,
        edge_vmax=edge_vmax,
        edge_threshold=edge_threshold,
        edge_kwargs=edge_kwargs,
        node_kwargs=node_kwargs,
        colorbar=colorbar,
    )

    if output_file is not None:
        display.savefig(output_file)
        display.close()
        display = None

    return display


@fill_doc
def plot_markers(
    node_values,
    node_coords,
    node_size="auto",
    node_cmap=plt.cm.viridis_r,
    node_vmin=None,
    node_vmax=None,
    node_threshold=None,
    alpha=0.7,
    output_file=None,
    display_mode="ortho",
    figure=None,
    axes=None,
    title=None,
    annotate=True,
    black_bg=False,
    node_kwargs=None,
    colorbar=True,
    radiological=False,
):
    """Plot network nodes (markers) on top of the brain glass schematics.

    Nodes are color coded according to provided nodal measure. Nodal measure
    usually represents some notion of node importance.

    Parameters
    ----------
    node_values : array_like of length n
        Vector containing nodal importance measure. Each node will be colored
        according to corresponding node value.

    node_coords : numpy array_like of shape (n, 3)
        3d coordinates of the graph nodes in world space.

    node_size : 'auto' or scalar or array-like, default='auto'
        Size(s) of the nodes in points^2. By default the size of the node is
        inversely proportional to the number of nodes.

    node_cmap : :obj:`str` or colormap, default=plt.cm.viridis_r.
        Colormap used to represent the node measure.

    node_vmin : :obj:`float` or None, default=None
        Lower bound of the colormap. If `None`, the min of the node_values is
        used.

    node_vmax : :obj:`float` or None, default=None
        Upper bound of the colormap. If `None`, the min of the node_values is
        used.

    node_threshold : :obj:`float` or None, default=None
        If provided only the nodes with a value greater than node_threshold
        will be shown.

    alpha : :obj:`float` between 0 and 1, default=0.7
        Alpha transparency for markers.
    %(output_file)s

    display_mode : :obj:`str`, default='ortho'
        Choose the direction of the cuts: 'x' - sagittal, 'y' - coronal,
        'z' - axial, 'l' - sagittal left hemisphere only,
        'r' - sagittal right hemisphere only, 'ortho' - three cuts are
        performed in orthogonal directions. Possible values are: 'ortho',
        'x', 'y', 'z', 'xz', 'yx', 'yz', 'l', 'r', 'lr', 'lzr', 'lyr',
        'lzry', 'lyrz'.
    %(figure)s
    %(axes)s
    %(title)s
    %(annotate)s
    %(black_bg)s
        Default=False.
    node_kwargs : :obj:`dict` or None, default=None
        will be passed as kwargs to the plt.scatter call that plots all
        the nodes in one go
    %(colorbar)s
        Default=True.
    %(radiological)s

    Returns
    -------
    display : :class:`~nilearn.plotting.displays.OrthoProjector` or None
        An instance of the OrthoProjector class. If ``output_file`` is defined,
        None is returned.
    """
    node_values = np.array(node_values).flatten()
    node_coords = np.array(node_coords)

    # Validate node_values
    if node_values.shape != (node_coords.shape[0],):
        msg = (
            "Dimension mismatch: 'node_values' should be vector of length "
            f"{len(node_coords)}, "
            f"but current shape is {node_values.shape} "
            f"instead of {(node_coords.shape[0], )}"
        )
        raise ValueError(msg)

    display = plot_glass_brain(
        None,
        display_mode=display_mode,
        figure=figure,
        axes=axes,
        title=title,
        annotate=annotate,
        black_bg=black_bg,
        radiological=radiological,
    )

    if isinstance(node_size, str) and node_size == "auto":
        node_size = min(1e4 / len(node_coords), 100)

    # Filter out nodes with node values below threshold
    if node_threshold is not None:
        if node_threshold > np.max(node_values):
            msg = (
                f"Provided 'node_threshold' value: {node_threshold} "
                "should not exceed "
                f"highest node value: {np.max(node_values)}"
            )
            raise ValueError(msg)

        retained_nodes = node_values > node_threshold
        node_values = node_values[retained_nodes]
        node_coords = node_coords[retained_nodes]
        if isinstance(node_size, collections.abc.Iterable):
            node_size = [
                size
                for ok_retain, size in zip(retained_nodes, node_size)
                if ok_retain
            ]

    # Calculate node colors based on value
    node_vmin = np.min(node_values) if node_vmin is None else node_vmin
    node_vmax = np.max(node_values) if node_vmax is None else node_vmax
    if node_vmin == node_vmax:
        node_vmin = 0.9 * node_vmin
        node_vmax = 1.1 * node_vmax
    norm = mpl.colors.Normalize(vmin=node_vmin, vmax=node_vmax)
    node_cmap = (
        plt.get_cmap(node_cmap) if isinstance(node_cmap, str) else node_cmap
    )
    node_color = [node_cmap(norm(node_value)) for node_value in node_values]

    # Prepare additional parameters for plt.scatter
    node_kwargs = {} if node_kwargs is None else node_kwargs
    node_kwargs.update([("alpha", alpha)])

    display.add_markers(
        marker_coords=node_coords,
        marker_color=node_color,
        marker_size=node_size,
        **node_kwargs,
    )

    if colorbar:
        display._colorbar = True
        display._show_colorbar(cmap=node_cmap, norm=norm)

    if output_file is not None:
        display.savefig(output_file)
        display.close()
        display = None

    return display


@fill_doc
def plot_carpet(
    img,
    mask_img=None,
    mask_labels=None,
    t_r=None,
    detrend=True,
    output_file=None,
    figure=None,
    axes=None,
    vmin=None,
    vmax=None,
    title=None,
    cmap="gray",
    cmap_labels=plt.cm.gist_ncar,
    standardize=True,
):
    """Plot an image representation of :term:`voxel` intensities across time.

    This figure is also known as a "grayplot" or "Power plot".

    Parameters
    ----------
    %(img)s
        4D image.

    mask_img : Niimg-like object or None, default=None
        Limit plotted voxels to those inside the provided mask.
        If a 3D atlas is provided, voxels will be grouped by atlas
        value and a colorbar will be added to the left side of the figure
        with atlas labels.
        If not specified, a new mask will be derived from data.
        See :ref:`extracting_data`.

    mask_labels : :obj:`dict` or None, default=None
        If ``mask_img`` corresponds to an atlas, then this dictionary maps
        values from the ``mask_img`` to labels. Dictionary keys are labels
        and values are values within the atlas.
    %(t_r)s

        .. note::
            If ``t_r`` is not provided, it will be inferred from ``img``'s
            header (``img.header.get_zooms()[-1]``).

        .. versionadded:: 0.9.1
            Prior to this, ``t_r`` would be inferred from ``img`` without
            user input.

    detrend : :obj:`bool`, default=True
        Detrend and z-score the data prior to plotting.
    %(output_file)s
    %(figure)s
    %(axes)s
    %(vmin)s
    %(vmax)s
    %(title)s
    %(cmap)s

        Default=`gray`.

    cmap_labels : :class:`matplotlib.colors.Colormap`, or :obj:`str`, \
                  default=`plt.cm.gist_ncar`
        If ``mask_img`` corresponds to an atlas, then cmap_labels
        can be used to define the colormap for coloring the labels placed
        on the side of the carpet plot.

    %(standardize)s

        .. note::

            Added to control passing value to `standardize` of ``signal.clean``
            to call new behavior since passing "zscore" or True (default) is
            deprecated. This parameter will be deprecated in version 0.13 and
            removed in version 0.15.

    Returns
    -------
    figure : :class:`matplotlib.figure.Figure`
        Figure object with carpet plot.

    Notes
    -----
    This figure was originally developed in :footcite:t:`Power2017`.

    In cases of long acquisitions (>800 volumes), the data will be downsampled
    to have fewer than 800 volumes before being plotted.

    References
    ----------
    .. footbibliography::

    """
    img = _utils.check_niimg_4d(img, dtype="auto")

    # Define TR and number of frames
    t_r = t_r or img.header.get_zooms()[-1]
    n_tsteps = img.shape[-1]

    if mask_img is None:
        mask_img = compute_epi_mask(img)
    else:
        mask_img = _utils.check_niimg_3d(mask_img, dtype="auto")

    is_atlas = len(np.unique(mask_img.get_fdata())) > 2
    if is_atlas:
        background_label = 0

        atlas_img_res = resample_to_img(
            mask_img,
            img,
            interpolation="nearest",
            copy_header=True,
            force_resample=False,  # TODO change to True in 0.13.0
        )
        atlas_bin = math_img(
            f"img != {background_label}",
            img=atlas_img_res,
        )
        masker = NiftiMasker(atlas_bin, target_affine=img.affine)

        data = masker.fit_transform(img)
        atlas_values = masker.transform(atlas_img_res)
        atlas_values = np.squeeze(atlas_values)

        if mask_labels:
            label_dtype = type(next(iter(mask_labels.values())))
            if label_dtype != atlas_values.dtype:
                logger.log(f"Coercing atlas_values to {label_dtype}")
                atlas_values = atlas_values.astype(label_dtype)

        # Sort data and atlas by atlas values
        order = np.argsort(atlas_values)
        order = np.squeeze(order)
        atlas_values = atlas_values[order]
        data = data[:, order]
    else:
        data = apply_mask(img, mask_img)

    # Detrend and standardize data
    if detrend:
        data = clean(data, t_r=t_r, detrend=True, standardize=standardize)

    if figure is None:
        if not axes:
            figsize = (10, 5)
            figure = plt.figure(figsize=figsize)
        else:
            figure = axes.figure

    if axes is None:
        axes = figure.add_subplot(1, 1, 1)
    else:
        assert axes.figure is figure, "The axes passed are not in the figure"

    # Determine vmin and vmax based on the full data
    std = np.mean(data.std(axis=0))
    default_vmin = data.mean() - (2 * std)
    default_vmax = data.mean() + (2 * std)

    # Avoid segmentation faults for long acquisitions by decimating the data
    LONG_CUTOFF = 800
    # Get smallest power of 2 greater than the number of volumes divided by the
    # cutoff, to determine how much to decimate (downsample) the data.
    n_decimations = int(np.ceil(np.log2(np.ceil(n_tsteps / LONG_CUTOFF))))
    data = data[:: 2**n_decimations, :]

    if is_atlas:
        # Define nested GridSpec
        legend = False
        wratios = [2, 100, 20]
        gs = mgs.GridSpecFromSubplotSpec(
            1,
            2 + int(legend),
            subplot_spec=axes.get_subplotspec(),
            width_ratios=wratios[: 2 + int(legend)],
            wspace=0.0,
        )

        ax0 = plt.subplot(gs[0])
        ax0.set_xticks([])
        ax0.imshow(
            atlas_values[:, np.newaxis],
            interpolation="none",
            aspect="auto",
            cmap=cmap_labels,
        )
        if mask_labels:
            # Add labels to middle of each associated band
            mask_labels_inv = {v: k for k, v in mask_labels.items()}
            ytick_locs = [
                np.mean(np.where(atlas_values == i)[0])
                for i in np.unique(atlas_values)
            ]
            ax0.set_yticks(ytick_locs)
            ax0.set_yticklabels(
                [mask_labels_inv[i] for i in np.unique(atlas_values)]
            )
        else:
            ax0.set_yticks([])

        # Carpet plot
        if compare_version(mpl.__version__, ">=", "3.8.0rc1"):
            axes.remove()  # remove axes for newer versions of mpl
        axes = plt.subplot(gs[1])  # overwrites axes with older versions of mpl
        axes.imshow(
            data.T,
            interpolation="nearest",
            aspect="auto",
            cmap=cmap,
            vmin=vmin or default_vmin,
            vmax=vmax or default_vmax,
        )
        ax0.tick_params(axis="both", which="both", length=0)
    else:
        axes.imshow(
            data.T,
            interpolation="nearest",
            aspect="auto",
            cmap=cmap,
            vmin=vmin or default_vmin,
            vmax=vmax or default_vmax,
        )

    axes.grid(False)
    axes.set_yticks([])
    axes.set_yticklabels([])

    # Set 10 frame markers in X axis
    interval = max(
        (int(data.shape[0] + 1) // 10, int(data.shape[0] + 1) // 5, 1)
    )
    xticks = list(range(data.shape[0])[::interval])
    axes.set_xticks(xticks)
    axes.set_xlabel("time (s)")

    if title:
        axes.set_title(title)

    labels = t_r * (np.array(xticks))
    labels *= 2**n_decimations
    axes.set_xticklabels([f"{t:.02f}" for t in labels.tolist()])

    # Remove and redefine spines
    for side in ["top", "right"]:
        # Toggle the spine objects
        axes.spines[side].set_color("none")
        axes.spines[side].set_visible(False)

    axes.xaxis.set_ticks_position("bottom")
    axes.spines["bottom"].set_position(("outward", 10))

    if not mask_labels:
        axes.yaxis.set_ticks_position("left")
        buffer = 20 if is_atlas else 10
        axes.spines["left"].set_position(("outward", buffer))
        axes.set_ylabel("voxels")

    if output_file is not None:
        figure.savefig(output_file)
        plt.close(figure)
        figure = None

    return figure


def plot_img_comparison(
    ref_imgs,
    src_imgs,
    masker,
    plot_hist=True,
    log=True,
    ref_label="image set 1",
    src_label="image set 2",
    output_dir=None,
    axes=None,
):
    """Create plots to compare two lists of images and measure correlation.

    The first plot displays linear correlation between :term:`voxel` values.
    The second plot superimposes histograms to compare values distribution.

    Parameters
    ----------
    ref_imgs : nifti_like
        Reference images.

    src_imgs : nifti_like
        Source images.

    masker : NiftiMasker object
        Mask to be used on data.

    plot_hist : :obj:`bool`, default=True
        If True then histograms of each img in ref_imgs will be plotted
        along-side the histogram of the corresponding image in src_imgs.

    log : :obj:`bool`, default=True
        Passed to plt.hist.

    ref_label : :obj:`str`, default='image set 1'
        Name of reference images.

    src_label : :obj:`str`, default='image set 2'
        Name of source images.

    output_dir : :obj:`str` or None, default=None
        Directory where plotted figures will be stored.

    axes : :obj:`list` of two matplotlib Axes objects, or None, default=None
        Can receive a list of the form [ax1, ax2] to render the plots.
        By default new axes will be created.

    Returns
    -------
    corrs : :class:`numpy.ndarray`
        Pearson correlation between the images.

    """
    # note: doesn't work with 4d images;
    # when plot_hist is False creates two empty axes and doesn't plot anything
    corrs = []
    for i, (ref_img, src_img) in enumerate(zip(ref_imgs, src_imgs)):
        if axes is None:
            _, (ax1, ax2) = plt.subplots(
                1,
                2,
                figsize=(12, 5),
                **_constrained_layout_kwargs(),
            )
        else:
            (ax1, ax2) = axes
        ref_data = masker.transform(ref_img).ravel()
        src_data = masker.transform(src_img).ravel()
        if ref_data.shape != src_data.shape:
            warnings.warn("Images are not shape-compatible")
            return

        corr = stats.pearsonr(ref_data, src_data)[0]
        corrs.append(corr)

        if plot_hist:
            ax1.scatter(
                ref_data,
                src_data,
                label=f"Pearsonr: {corr:.2f}",
                c="g",
                alpha=0.6,
            )
            x = np.linspace(*ax1.get_xlim(), num=100)
            ax1.plot(x, x, linestyle="--", c="k")
            ax1.grid("on")
            ax1.set_xlabel(ref_label)
            ax1.set_ylabel(src_label)
            ax1.legend(loc="best")

            ax2.hist(ref_data, alpha=0.6, bins=128, log=log, label=ref_label)
            ax2.hist(src_data, alpha=0.6, bins=128, log=log, label=src_label)
            ax2.set_title("Histogram of imgs values")
            ax2.grid("on")
            ax2.legend(loc="best")

            if output_dir is not None:
                output_dir = Path(output_dir)
                output_dir.mkdir(exist_ok=True, parents=True)
                plt.savefig(output_dir / f"{int(i):04}.png")

    return corrs
